# 제 8장. 누가 액세스하고 있는지를 확인하는 인증
## 8.1. 인증이란?
- HTTP 에서 사용하는 인증 방법
  - BASIC 인증
  - DIGEST 인증
  - SSL 클라이언트 인증
  - 폼 베이스 인증

## 8.2. BASIC 인증
- 웹 서버와 대응하고 있는 클라이언트 사이에서 이뤄지는 인증 방식

### 8.2.1. BASIC 인증 수순
1. 클라이언트가 리퀘스트 송신
    ```http
    GET /private/ HTTP/1.1 
    Host: hackr.jp
    ```
2. BASIC 인증이 필요한 리소스가 있는 경우 서버는 상태코드 401 Authorization Required와 함께 **인증의 방식(BASIC), Request-URI의 보호 공간을 식별하기 위한 문자열(realm)을 WWW-Authenticate 헤더 필드에 포함시켜 리스폰스를 반환**
    ```http
    HTTP/1.1  401 Authorization Required
    Date:Mon, 19 Sep 2011 08:38:32 GMT
    Server: Apache/2.2.3 (Unix)
    WWW-Authenticate: Basic realm="Input Your ID and Password"
    ```
3. 상태 코드 401을 받은 클라이언트는 BASIC 인증을 위해 유저ID와 패스워드를 서버에 송신해야 함.<br>**송신하는 문자열은 유저ID와 패스워드를 콜론 ‘:’ 으로 연결한 문장을 Base64라 불리는 형식으로 인코드한 것.** <br>ex) ID가 guest이고 패스워드가 guest인 경우 guest:guest 문자열이 되는데 이를 Base64 인코드하면 Z3Vlc3Q6Z3Vlc3Q= 이 된다. 이 문자열을 Authorization 헤더 필드에 포함해서 리퀘스트를 송신
    ```http
    Get /private/ HTTP/1.1
    Host: hacker.jp
    Authorization: Basic Z3Vlc3Q6Z3Vlc3Q=
    ```
4. Authorization 헤더 필드를 포함한 리퀘스트를 수신한 서버는 인증 정보가 정확한지 여부를 판단. <br> 인증 정보가 정확하면 Request-URI 리소스를 포함한 리스폰스를 반환
    ```http
    HTTP/1.1  200 OK
    Date:Mon, 19 Sep 2011 08:38:35 GMT
    Server: Apache/2.2.3 (Unix)
    ```

- BASIC 인증에서는 **Base64 라는 인코딩 형식을 사용하고 있지만, 암호화는 아니기 때문에 아무런 부가정보 없이도 복호화할 수 있다**
- HTTPS 등에서 암호화되지 않은 통신 경로 상에서 BASIC 인증을 해서 도청된 경우, 복호화된 유저 아이디와 패스워드를 빼앗길 가능성이 있다
- 한번 BASIC 인증을 하면, 일반 브라우저에서는 로그아웃 할 수 없다
- BASIC 인증은 사용상의 문제와 많은 웹사이트에서 요구되는 보안 등급에는 미치치 못한다

## 8.3 DIGEST 인증
- 챌린지 리스폰스 방식이 사용되고 있어서 BASIC 인증처럼 패스워드를 있는 그대로 직접 보내지는 않는다.
- 챌린지 리스폰스 방식
  - 최초에 A가 B에게 인증 요청
  - B가 A에게 챌린지 코드 송신
  - A가 챌린지 코드 수신 후 리스폰스 코드 (패스워드와 챌린지 코드 이용해서 계산한 결과) 계산
  - 리스폰스 코드를 B에게 다시 송신 인증

### 8.3.1. DIGEST 인증 수순 
1. 클라이언트가 리퀘스트 송신
    ```http
    GET /digest /HTTP/1.1 
    Host: hackr.jp
    ```
2. 인증이 필요한 리소스가 있는 경우 서버는 상태코드 401 Authorization Required와 함께 **챌린지 리스폰스 방식의 인증에 필요한 챌린지 코드 (nonce) 를 WWW-Authenticate 헤더필드에 포함해서 리스폰스 반환**
    ```http
    HTTP/1.1  401 Authorization Required
    WWW-Authenticate: Digest realm="DIGEST", nonce="sdfsdfsdfsasdfsdf", ...
    ```
    반드시 포함되어야 하는 정보는 "realm" 과 "nonce" 이다

3. 상태 코드 401을 받은 클라이언트는 DIGEST 인증을 위해 필요한 정보를 헤더 필드에 포함하여 반환한다.<br>**Authorization 헤더 필드에 반드시 포함되어야 하는 정보는 username, realm, nonce, uri, response 이다**<br>이 중 realm, nonce 는 서버에서 받은 것을 사용한다
    ```http
    Get /digest/ HTTP/1.1
    Host: hacker.jp
    Authorization: Digest username="guest", realm="DIGEST", nonce="sdfsdfsdfsasdfsdf", uri="/digest", response="ffffffffffff", ...
    ```
    - username : 지정된 Realm 에서 인증 가능한 사용자 이름
    - response (리스폰스 코드) : Request-Digest 라고 불리는데 패스워드 문자열을 MD5 로 계산한 것
4. Authorization 헤더 필드를 포함한 리퀘스트를 수신한 서버는 인증 정보가 정확한지 여부를 판단. <br> 인증 정보가 정확하면 Request-URI 리소스를 포함한 리스폰스를 반환
    ```http
    HTTP/1.1  200 OK
    Authentication-Info: ...
    ```
    - DIGEST 인증에서는 패스워드 도청을 방지하기 위한 보호 기능은 제공하고 잇지만 이외에 위장을 방지하는 기능은 제공하지 않는다
    - DIGEST 인증도 BASIC 인증과 마찬가지로 사용상의 문제와 많은 웹사이트에서 요구하는 보안 등급에 미치지 못한다는 점에서 그다지 사용되고 있지 않다




챌린지 코드(nonce)는 401응답마다 다르다. (매번 생성된다.)
계산 결과를 보내기 때문에 BASIC 인증보다는 낫지만 이외의 위장에 대한 보안이 떨어진다.
8.3.1 인증 절차
요청에 인증이 필요하면 서버는 401상태코드와 WWW-Authenticate 헤더에 챌린지 코드(nonce)를 담아 응답한다.
클라이언트는 챌린지 코드와 비밀번호를 MD5로 계산한 리스폰스 코드를 Authorization 헤더에 담아 서버에 전송한다.
서버는 인증에 성공하면 200과 리소스를, 실패하면 401 상태코드로 응답한다.


## 8.4 SSL 클라이언트 인증
- 유저 아이디, 패스워드를 사용한 인증방식은 2가지 정보가 정확하다면 본인으로 인증 가능하다.
  - 따라서 이 정보가 도난된다면 제 3자가 위장할 수 있다
  - 이를 방지하기 위한 대책 중 하나로 SSL 클라이언트 인증이 사용된다
- **SSL 클라이언트 인증 : HTTPS의 클라이언트 인증서를 이용한 인증 방식**
  - 클라이언트 증명서를 인증할 때만 사용하는 방식으로 사전에 등록된 클라이언트에서의 액세스인지 확인한다.

### 8.4.1 인증 절차
- SSL 클라이언트 인증은 사전에 클라이언트에 클라이언트 인증서를 설치해 둘 필요가 있다
1. 요청에 인증이 필요하면 서버는 클라이언트에게 클라이언트 증명서를 요청하는 "Certificate Request" 메시지를 보낸다.
2. 클라이언트는 클라이언트 증명서를 "Client Certificate" 라는 메시지를 송신한다. 
3. 서버가 클라이언트 증명서를 검증하여 정확하다면 클라이언트의 공개키를 취득한다. 이후에 HTTPS 에 의한 암호를 개시한다.

### 8.4.2. SSL 클라이언트 인증은 2-factor 인증에서 사용된다
- 대부분 SSL 클라이언트 인증은 단독으로 사용되지 않고, 폼 베이스 인증과 합쳐서 2-factor 인증의 하나로서 이용된다
- 2-factor 인증 : 예를 들면 패스워드라는 1개의 요소만이 아닌 이용자가 가진 다른 정보를 병용해서 인증하는 방법
  - ex. 1번째 인증 정보로서 SSL 클라이언트 인증을 사용하여 클라이언트의 컴퓨터를 인증<br>다른 인증 정보로서 패스워드를 사용하여 유저의 본인 확인

### 8.4.3. SSL 클라이언트 인증은 이용하는데 비용이 필요하다
- 클라이언트 증명서를 이용하기 위해서는 비용이 필요하다

## 8.5 폼 베이스 인증
- HTTP 정식 인증 방식은 아니다. 
- 클라이언트가 서버 상의 웹 어플리케이션에 자격 정보 (Credential) 를 송신하여 그 자격 정보의 검증 결과에 따라 인증하는 방식이다.
  
### 8.5.1. 인증의 대부분은 폼 베이스 인증
- **웹 사이트의 인증 기능으로서 요구되는 기능의 레벨을 충족시킨 표준이 존재하지 않기에**, 웹 어플리케이션에서 제각각 구현하는 폼 베이스 인증을 채용하는 수밖에 없다
- 공통 사양이 결정되어 있지 않은 폼베이스 인증에서는 웹사이트 별로 다르게 구현하고 있다

### 8.5.2. 세션 관리와 쿠키에 의한 구현
- 폼 베이스 인증에서는, 세션 관리를 위해 쿠키를 사용하고 있다
- HTTP 는 stateless 프로토콜이기에, 방금 전에 인증했던 유저라는 상태를 유지할 수 없다.
  - 따라서 **세션 관리와 쿠키를 사용하여 HTTP에 없는 상태 관리 기능을 보충한다**
1. POST 메소드로 엔티티 바디에 자격 정보를 저장한다. 이 때 HTML 폼 화면 표시와 입력 데이터 송신에는 HTTPS 통신을 사용한다.
2. **인증에 성공하면 서버는 세션 ID를 발행하고 Set-Cookie 헤더 필드에 세션 ID 를 저장해서 리스폰스를 반환한다**
3. 서버로부터 세션 ID 를 받은 클라이언트는 받은 세션 ID를 쿠키에 저장한다.<br>서버에 리퀘스트를 송신할 때는 브라우저가 자동으로 쿠키를 송출하기에 세션ID 가 서버에 송신된다
- 폼베이스 인증에서는 자격 정보를 교환하는 방법이 표준화되어 있지 않을 뿐만 아니라, 패스워드 등 자격 정보를 서버에 어떻게 보존해야 할지도 표준화 되어 있지 않다
- 일반적으로 안전한 방법으로서 패스워드를 salt 라는 부가정보를 사용해서 해시 알고리즘으로 계산한 값을 저장한다