# 제 3장. HTTP 정보는 HTTP 메시지에 있다
## 3.2. 리퀘스트 메시지와 리스폰스 메시지의 구조
- 리퀘스트 메시지는 최상단에 `리퀘스트 라인` 을 갖고, 리스폰스 메시지는 최상단에 `상태 라인` 을 갖는다
```http
// 리퀘스트 메시지
GET / HTTP/1.1
...

// 리스폰스 메시지
HTTP/1.1 200 OK
```

## 3.3. 인코딩으로 전송 효율을 높이다
- 전송할 때 **인코딩(변환)을 실시함으로써 전송 효율을 높일 수 있다**
  - 다량의 액세스를 효율 좋게 처리할 수 있다

### 3.3.1 메시지 바디와 엔티티 바디의 차이
- 메시지 : HTTP 통신의 기본 단위, 옥텟(8bit) 시퀀스로 구성되고 통신을 통해 전송된다.
- 엔티티 : **리퀘스트, 리스폰스의 페이로드로 전송되는 정보**. 엔티티 헤더 필드와 엔티티 바디로 구성된다.
![alt text](image-1.png)
- HTTP 메시지 바디는 리퀘스트, 리스폰스의 엔티티 바디를 운반한다. 
![alt text](image.png)
    - Entity Body는 전혀 가공되지 않은 데이터만을 담고 있고, 해당 raw data의 의미를 나타내는 정보는 Entity Header에 담겨 있다. 
      - 예를 들어, Content-Type 엔터티 헤더는 Entity Body를 어떻게 해석해야 하는 지를 알려주는 정보
      - Content-Encoding 엔터티 헤더는 Entity Body가 압축되었거나 추가적인 인코인 처리가 되었는지를 알려준다.

- **기본적으로 메시지 바디와 엔티티 바디는 같지만** 전송 코딩이 적용된 경우 엔티티 바디의 내용이 변경되므로 메시지 바디와 달라진다.

### 3.3.2. 압축해서 보내는 콘텐츠 코딩
- `콘텐츠 코딩` : 엔티티에 적용하는 인코딩으로, **엔티티 정보를 유지한 채로 압축**
  - 콘텐츠 코딩된 엔티티는 수신한 클라이언트 측에서 디코딩한다
  - 주요 콘텐츠 압축
    - gzip (GNU zip)
    - compress (UNIX 표준 압축)

### 3.3.3. 분해해서 보내는 청크 전송 코딩
- 사이즈가 큰 데이터를 전송하는 경우 데이터를 분할해서 조금씩 표시할 수 있다
  - `청크 전송 코딩` : 엔티티 바디를 분할하는 기능
- 다음 청크 사이즈를 16진수로 사용해서 단락을 표시하고 엔티티 바디 끝에는 0(CR+LF) 를 기록한다
- 청크 전송코딩된 엔티티 바디는 **수신한 클라이언트 측에서 원래 엔티티 바디로 디코딩** 한다

## 3.4. 여러 데이터를 보내는 멀티파트
- 메일의 경우, 메일의 본문이나 복수 첨부파일을 붙여서 함께 보낼 수 있다
  - `MIME` (Multipurpose Internet Mail Extensions) 으로 불리는 메일로, 텍스트나 영상, 이미지 같은 여러 다른 데이터를 다루기 위한 기능을 사용한다
  - MIME 의 확장 사양에 있는 `멀티파트` 라고 하는 여러 다른 종류의 데이터를 수용하는 방법을 사용하고 있다
- HTTP 도 멀티파트에 대응하고 있어서 **하나의 메시지 바디 내부에 엔티티 여러개 포함시켜 보낼 수 있다**
- `multipart/form-data` : web 폼으로부터 파일 업로드에 사용된다
```http
Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name="field1"

JoeBlow
--AaB03x
Content-Disposition: form-data; name="pics"; filename="file1.txt"
Content-Type: text/plain

(file1.txt데이터)
--AaB03x--
```
- HTTP 메시지로 멀티파트를 사용할 때는 `Content-Type` 헤더 필드를 사용한다.
- 멀티파트 **각각의 엔티티를 구분하기 위해** boundary 문자열을 사용한다.
- 멀티파트는 **파트마다 헤더 필드가 포함**되고 파트를 내부에 포함할 수도 있다.

## 3.5. 일부분만 받는 레인지 리퀘스트
- 다운로드 중 커넥션이 끊어지면 처음부터 다시 다운로드를 해야 했다<br>
이러한 문제를 해결하기 위해 `리줌` 이라는 기능이 나왔다
    - 리줌을 통해 이전에 다운로드를 한 곳부터 다운로드를 재개할 수 있게 되었다
- 이 기능을 실현하려면 엔티티의 범위를 지정해서 다운로드를 해야하는데, **범위를 지정해서 리퀘스트 하는 것** 을 `레인지 리퀘스트` 라고 한다
```http
// Request
GET /tip.jpg HTTP/1.1
Host: www.naver.com
Range: bytes = 5001-10000

// Response
HTTP/1.1 206 Partial Content
Content-Range: bytes 5001-10000/10000
Content-Length: 5000
Content-Type: image/jpeg
```
- 레인지 리퀘스트를 할 때는 Range 헤더 필드를 사용해서 **리소스의 바이트 레인지를 지정** 한다
- 레인지 리퀘스트에 대한 리스폰스는 상태코드 206 Partial Content 이다
  - 상태코드 206 리스폰스 메시지가 **복수 범위의 내용을 포함하는 때에 사용** 된다
  - 복수 범위 레인지 리퀘스트에 대한 리스폰스는 multipart/byteranges 로 리스폰스가 돌아온다
- 서버가 레인지 리퀘스트를 지원하지 않는 경우, 상태코드 200 OK 라는 리스폰스 메시지로 **완전한 엔티티가 돌아온다**

## 3.6. 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션
- 같은 콘텐츠이지만 여러 개의 페이지를 가진 웹 페이지가 존재한다.
    - 내용은 같지만, 표시되는 언어가 서로 다른 웹페이지가 예시
- `콘텐츠 네고시에이션` : 클라이언트와 서버가 제공하는 리소스의 내용에 대해 교섭하는 것, **클라이언트에 더욱 적절한 리소스를 제공하기 위한 구조**
    - **언어와 문자, 인코딩** 등을 기준으로 제공한다
    - 판단 기준은 리퀘스트 메시지에 포함된 **리퀘스트 헤더 필드** 이다
      - Accept
      - Accept-Charset
      - Accept-Encoding
      - Accept-Language
      - Content-Language
- 서버 구동형 네고시에이션
  - 서버 측에서 콘텐츠 네고시에이션을 하는 방식
  - **서버 측에서 리퀘스트 헤더 필드 정보를 참고해서 자동 처리**한다
- 에이전트 구동형 네고시에이션
  - 클라이언트 측에서 콘텐츠 네고시에이션을 하는 방식
  - 브라우저에 표시된 선택지에서 **유저가 수동 선택**
- 트랜스페어런트 네고시에이션
  - 서버와 클라이언트가 각각 콘텐츠 네고시에이션을 하는 방식