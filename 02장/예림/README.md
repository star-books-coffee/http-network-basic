# 2장. 간단한 프로토콜 HTTP
## HTTP는 클라이언트와 서버 간에 통신을 한다
- HTTP는 클라이언트와 서버의 역할을 명확하게 구별하고 있다.

## 리퀘스트와 리스폰스를 교환하여 성립
- 서버 측은 리퀘스트를 수신하지 않으면 리스폰스가 발생하는 경우는 없다.

### 리퀘스트
- 아래는 클라이언트 측으로부터 HTTP 서버에 송신된 리퀘스트 내용이다.
  ```
  GET /index.html HTTP/1.1
  Host: www.hackr.ip
  ```
  - GET : 메서드
  - /index.html : 리소스
  - HTTP/1.1 : 클라이언트의 기능을 식별하기 위한 HTTP 버전 번호
- 리퀘스트 메시지는 메서드, URI, 프로토콜 버전, 옵션 리퀘스트 헤더 필드와 엔티티로 구성
  ![image](https://github.com/star-books-coffee/http-network-basic/assets/101961939/7eeb65c4-9e31-42f2-9cc6-39c5e613a23a)

### 리스폰스
```
HTTP /1.1 200 OK
Date: Tue, 10 Jul 2012 06:50:15 GMT
Content-Length: 362
Content-Type: text/html

<html>
```
- 프로토콜 버전, 상태 코드와 그 상태 코드를 설명한 프레이즈, 옵션의 리스폰스 헤더 필드와 바디로 구성
![image](https://github.com/star-books-coffee/http-network-basic/assets/101961939/311978a9-cb97-4118-8571-90198944bcd1)

## HTTP는 상태를 유지하지 않는 프로토콜
- HTTP는 상태를 계속 유지하지 않는 스테이트리스 프로토콜
- 전에 보냈던 리퀘스트나 리스폰스를 스스로 기억할 수 있는 구조가 아니다.
- 로그인 상태 유지 등 상태를 계속 유지하고 싶은 요구에 부응하기 위해 쿠키(Cookie) 기술 도입됨

## 리퀘스트 URI로 리소스를 식별
- HTTP는 URI로 인터넷 상의 리소스 지정
- 리퀘스트 URI를 지정하는 방법
  1. 모든 URI를 리퀘스트 URI에 포함
  ```
  GET http://hackr.jp/index.htm HTTP/1.1
  ```
  2. Host 헤더 필드에 네트워크 로케이션을 포함한다.
  ```
  GET /index.htm HTTP/1.1
  Host: hackr.jp
  ```
- 이것 외에도 특정 리소스가 아닌 서버 자신에게 리퀘스트를 송신하는 경우에는 리퀘스트 URI에 [*]를 지정할 수 있음
  - HTTP 서버가 지원하고 있는 메서드를 묻는 예
    ```
    OPTIONS * HTTP/1.1
    ```
## 서버에 임무를 부여하는 HTTP 메서드
- GET - 헤더에 If-Modified-Since로 지정된 시간 이후에 갱신된 경우에만 리소스를 되돌려주도록 설정 가능
- POST
- PUT - 파일 전송 / 일반 웹사이트에서는 보안상 사용 X / REST와 같이 웹끼리 연계하는 설계 양식에서 사용
- HEAD - 메시지 헤더 취득 / URI 유효성과 리소스 갱신 시간 확인
- DELETE - REST와 같이 웹끼리 연계하는 설계 양식에서 사용
- OPTIONS - 제공하고 이쓴ㄴ 메서드의 문의
- TRACE - 경로 조사 (프록시 등을 중계하여 오리진 서버에 접속할 때 그 동작 확인)
- CONNECT - 프록시에 터널링 요구

## 메서드를 사용해서 지시를 내리다
- aptjemsms 대문자와 소문자 구분하므로 대문자로 기재

## 지속 연결로 접속량을 절약
- HTTP 초기 버전에서는 HTTP 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 할 필요가 있었다.
- 그래서 리퀘스트를 보낼 때마다 쓸모없는 일이 발생해 통신량 증가
### 지속 연결 (Persistent Connection)
- 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결 유지 -> 오버헤드 줄여줘서 서버 부하 경감
### 파이프라인화
- 지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인(HTTP pipelining)화를 가능하게 한다.
- 파이프라인화를 하여 리스폰스를 기다리지 않고 다음 리퀘스트 보내기 가능

## 쿠키를 이용한 상태 관리
> - HTTP는 stateless => 과거에 교환했던 리퀘스트와 리스폰스의 상태를 관리하지 않음 => 과거 상태를 근거로 해서 현재 리퀘스트를 처리하는 것이 불가
> - 인증이 필요한 웹 페이지에서 상태 관리를 하지 않는다면 재차 로그인 정보를 보내든지 리퀘스트마다 매개변수나 추가 정보를 붙여서 로그인 상태를 관리해야 하는 상황이 발생
> - stateless 프로토콜이라는 특징은 남겨둔 채, 이와 같은 문제를 해결하기 위해 쿠키라는 시스템이 도입됨
- 쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템
- 서버에서 `Set-Cookie`라는 헤더 필드에 값을 넣어서 보내면 다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때 쿠키 값 넣어서 송신하고 서버는 그걸 가지고 어느 클라이언트가 접속했는지 체크
- 예시

  (1) 리퀘스트(쿠키를 가지고 있지 않은 상태)
    ```
    GET /reader/ HTTP /1.1
    Host: www.yelim.com
    * 헤더 필드에 쿠키는 없다
    ```
  (2) 리스폰스(서버가 쿠키를 발행)
    ```
    HTTP /1.1 200 OK
    Date: Thu, 12, Jul 2024 07:12:20 GMT
    Server: Apache
    <Set-Cookie: sid=1352243435456; path=/;expires=Wed, => 10-Oct-12 17:12:20 GMT>
    Content-Type: text/plain; charset=UTF=8
    ```
  (3) 리퀘스트(보관하고 있던 쿠키를 자동 송신)
    ```
    GET /image/ HTTP /1.1
    Host: www.yelim.com
    Cookie: sid=1352243435456
    ```
