# 7장. 웹을 안전하게 지켜주는 HTTPS

## 7.1 HTTP의 약점
- 평문(암호화하지 않은) 통신이기 때문에 도청 가능
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 완전성을 증명할 수 없기 때문에 변조 가능

### 7.1.1 평문이기 때문에 도청 가능
#### TCP/IP는 도청 가능한 네트워크
  - TCP/IP의 구조의 통신 내용은 전부 통신 경로 도중에 엿볼 수 있다. 인터넷은 모든 곳에서 통신 내용이 도청될 가능성이 있다.
  - 암호화 통신은 메시지 속의 의미는 간파할 수 없을 수도 있겠지만 암호화된 메시지 자체는 엿볼 수 있다.
  - 네트워크 상을 흐르고 있는 패킷을 수집하는 것만으로도 도청 가능 (ex.Wireshark를 이용해 패킷 캡처)
#### 암호화로 도청을 피하다
암호화에는 몇 가지의 대상이 있다.


**1) 통신 암호화**
- HTTP에는 암호화 구조는 없지만 SSL이나 TLS라는 다른 프로토콜을 조합함으로써 통신 내용 암호화 가능
- SSL 등을 이용해 안전한 통신로를 확립하고 나서 그 통신로를 사용해 HTTP 통신을 한다.
- SSL을 조합한 HTTP를 HTTPS(HTTP Secure)나 HTTP over SSL이라 불리고 있음.


**2) 콘텐츠 암호화**
- 통신하는 콘텐츠의 내용 자체를 암호화
- HTTP를 사용해서 운반하는 내용을 암호화
- 이 경우, 클라이언트에서 HTTP 메시지를 암호화해서 출력하는 처리 필요
- 클라이언트와 서버가 콘텐츠의 암호화나 복호화 구조를 갖고 있는 것이 전제가 된다.

### 7.1.2 통신 상대를 확인하지 않기 때문에 위장 가능
- HTTP를 사용한 리퀘스트나 리스폰스에서는 통신 상대를 확인하지 않음.

#### 누구나 리퀘스트할 수 있다
- HTTP에 의한 통신에는 상대가 누구인지 확인하는 처리는 없다 ➡️ 누구든지 리퀘스트를 보낼 수 있다.
- 리퀘스트가 오면 상대가 누구든지 무언가의 리스폰스 반환(IP주소나 포트 등에서 그 웹서버에 액세스 제한이 없느 경우)
- 이 점이 약점이 될 수 있음
  - 위장한 웹 서버일 수 있다.
  - 위장한 클라이언트일 수 있다.
  - 통신하고 있는 상대가 접근이 허가된 상대인지 아닌지를 확인할 수 없다.
  - 어디의 누가 리퀘스트 했는지를 확인할 수 없다.
  - 의미없는 리퀘스트라도 수신하게 된다. DoS 공격을 방지할 수 없다.

#### 상대를 확인하는 증명서
- SSL은 암호화 뿐만 아니라 상대를 확인하는 수단으로 증명서 제공
- 증명서는 신뢰할 수 있는 제3자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다.
- 이 증명서를 이용해 통신 상대가 내가 통신하고자 하는 서버임을 나타냄
- 또한, 클라이언트가 증명서를 가짐으로써 본인확인을 하고, 웹 사이트 인증에서 이용 가능

### 7.1.3 완전성을 증명할 수 없기 때문에 변조 가능
- **완전성** : 정보의 정확성
  - 이것을 증명할 수 없다는 것은 **정보가 정확한지 아닌지를 확인할 수 없다**는 의미
 
#### 수신한 내용이 다를지도 모른다
- 리퀘스트나 리스폰스가 발신되고 상대가 수신할 때까지의 사이에 변조되었더라도 이 사실을 알 수 없다.
  ➡️ 발신된 리퀘스트나 리스폰스와 수신한 리퀘스트나 리스폰스가 같은지 아닌지를 확인할 수 없다.
- 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격 : 중간자 공격

#### 변조를 방지하려면?
- 확실하면서 편리한 방법은 현재로서는 존재하지 않음.
- 그 중에서도 자주 사용되는 방법은 MD5나 SHA-1 등의 **해시 값을 확인**하는 방법과 **파일의 디지털 서명을 확인하는 방법**
> 파일 다운로드 서비스를 제공하고 있는 웹 사이트에서는 PGP(Pretty Good Privacy)에 의한 서명과 MD5에 의한 해시 값을 제공하는 일이 있다. PGP는 파일을 작성했다는 증명을 위한 서명으로, MD5는 단방향성 함수에 의한 해시값이다.

- 확실히 방지하기에는 HTTPS를 사용할 필요가 있다.

## 7.2 HTTP + 암호화 + 인증 + 완전성 보호 = HTTPS

### 7.2.1 HTTP에 암호화와 인증과 완전성 보호를 더한 HTTPS
- HTTP에는 통신 상대의 서버나 클라이언트를 인증하는 수단이 없다.
- HTTP에 암호화나 인증 등의 구조를 더한 것이 HTTPS(HTTP Secure)

### 7.2.2 HTTPS는 SSL의 껍질을 덮어쓴 HTTP
- HTTPS는 새로운 애플리케이션 계층의 프로토콜은 아니다.
- HTTP 통신을 하는 소켓 부분을 SSL이나 TLS라는 프로토콜로 대체하고 있을 뿐
- 보통 HTTP는 TCP와 통신하지만 SSL을 사용한 경우에는 HTTPS는 SSL과 통신하고 SSL이 TCP와 통신하게 된다.
- SSL은 HTTP와는 독립된 프로토콜


![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSSTRXywQKcRMT7B6XqMC1AMWmDHX-MK_H1vw&s)


### 7.2.3 상호 간에 키를 교환하는 공개키 암호화 방식
- SSL에서는 공개키 암호화 방식 채용
- 현대의 암호는 알고리즘이 공개되어 있고 키를 비밀에 부침으로써 안전성을 유지

#### 공통키 암호의 딜레마
- 공통키 암호 : 암호화와 복호화에 하나의 키를 같이 사용하는 방식
- 상대방에게 키를 넘겨주지 않으면 안되고, 받은 키를 안전하게 보관해야 한다.

#### 두 개의 키를 사용하는 공개키 암호
- 공통키 암호의 문제를 해결하려고 한 것이 **공개키 암호**라는 방식
- 서로 다른 키 페어(쌍)을 사용한다.
  - 한 쪽은 **비밀키**, 한 쪽은 **공개키**

- 암호를 보내는 측이 상대의 공개키를 사용해 암호화하고, 암호화된 정보를 받아들인 상대는 자신의 비밀키를 사용해 복호화 실시
- 암호를 푸는 비밀키를 통신으로 보낼 필요가 없기 때문에 도청에 의해서 키를 빼앗길 걱정은 없음.
- 암호문과 공개키라는 정보에서 평문을 구하는 것은 매우 어려운 수학적 특징이 있어 간단하지는 않음

#### HTTPS는 하이브리드 암호 시스템
- HTTPS는 공통키 암호와 공개키 암호 양쪽 성질을 가진 하이브리드 암호 시스템
- 공개키 암호는 공통키 암호에 비해 처리 속도가 늦다.
- 두 가지 장점을 살릴 수 있도록 각각의 방식을 조합해서 사용
  - 키를 교환하는 곳에서는 공개키 암호 사용
  - 그 후의 통신에서 메시지를 교환하는 곳에서는 공통키 암호 사용

### 7.2.3 공개키가 정확한지 아닌지를 증명하는 증명서
- 공개키 암호의 문제점 : 공개키가 진짜인지 아닌지 증명할 수 없다.
- 해결 방법 : 인증기관(CA)과 그 기관이 발행하는 공개키 증명서가 이용되고 있음
- 과정

  1. 서버의 공개키를 인증 기관에 등록
  2. 인증 기관의 비밀키로 서버의 공개키에 디지털 서명으로 공개키 증명서를 작성 등록
  3. 서버의 공개키 증명서를 입수하고, 디지털 서명을 인증 기관의 공개키로 검증하고, 공개키가 진짜인지 확인
  4. 서버의 공개키로 암호화해서 메시지를 송신 기관에 등록
 
- 통신 중에는 어떤 방법을 사용하더라도 안전하게 전달하는 것은 어렵기 때문에 많은 브라우저가 주요 인증 기관의 공개키를 사전에 내장

#### 클라이언트를 확인하는 클라이언트 증명서
- 클라이언트 증명서를 이용하여 서버가 통신하고 있는 상대가 의도한 클라이언트인지 증명할 수 있다.
- 다만 몇 가지 문제점이 있다.

  - **증명서의 입수와 배포** : 유저가 클라이언트 증명서를 인스톨할 필요가 있음. 유저 수 만큼 비용이 든다.
  - **클라이언트의 실재를 증명할 뿐, 사용자의 존재 유무를 증명하지 않는다** : 증명서가 들어간 컴퓨터를 사용할 권한이 있다면 누구든지 클라이언트 증명서를 이용할 수 있다.

#### 자가 인증 기관 발행 증명서는 '나야 나' 증명서
- OpenSSL 등의 소프트웨어를 사용하면 **누구든지 인증 기관을 구축하여 서버 증명서를 발행할 수 있다**
- 그러나 이 서버 증명서는 인터넷 상에서 구실을 제대로 하지 못함.
- 독자적으로 구축한 인증 기관을 자가 인증 기관이라고 부르고, 거기서 발행한 쓸모 없는 증명서를 '나야 나 증명서'라고 부르기도 한다.

> 마이너 인증 기관을 사용하면 '나야 나' 증명서가 될 수도 있다.

### 7.2.5 안전한 통신을 하는 HTTPS 구조

<img width="566" alt="image" src="https://github.com/user-attachments/assets/630068e8-8bad-4bb7-bddf-6c8d003b2a85">

1. 클라이언트가 Client Hello 송신하며 SSL 통신 시작. **메시지**에는 클라이언트가 제공하는 SSL 버전 지정, 암호 스위트라고 불리는 리스트(사용하는 암호화 알고리즘이나 키 사이즈 등)이 포함되어 있음.
2. 서버가 SSL 통신이 가능한 경우 Serve rHello 응답. SSL 버전과 암호 스위트 포함. 서버의 암호 스위트 내용은 클라이언트에서 받은 암호 스위트의 내용에서 선택된 것
3. 서버가 Server Hello Done 메시지 송신. (최초의 SSL 네고시에이션 끝)
4. 클라이언트가 Client Key Exchange 메시지로 응답. 메시지에는 통신을 암호화하는 데 사용하는 Pre-Master secret 포함. 이 메시지는 3번의 공개키 증명서에서 꺼낸 공개키로 암호화되어 있음.
5. 클라이언트는 Change Cipher Spec 메시지 송신. 이 메시지는 이 메시지 이후의 통신은 암호키를 사용해서 진행하겠다는 것을 나타냄
6. 클라이언트는 Finished 메시지 손신. 이 메시지는 접속 전체의 체크 값 포함
7. 서버에서도 마찬가지로 Change Cipher Spec 메시지 송신
8. 서버에서도 마찬가지로 Finished 메시지 송신
9. 서버와 클라이언트의 Finished 메시지 교환이 완료되면 SSL에 의해서 접속 확립. 이제부터 애플리케이션 계층의 프로토콜에 의해 통신 (HTTP)
10. HTTP 리퀘스트 송신
11. 마지막에 클라이언트가 접속 끊음. close_notify 메시지를 송신


#### SSL은 느리다?
- SSL을 사용하면 통신이 지연된다.
  - 통신 속도 저하
  - CPU나 메모리 등의 리소스를 다량으로 소비
- HTTPS는 HTTP에 비해 2~100배 느림
- 근본적인 해결 방법은 없기 때문에 SSL 액셀레이터라는 하드웨어를 사용해 이 문제를 해결하기도 함

